<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <title>Azure Feature Wish List</title>
    <link rel="search" 
      type="application/opensearchdescription+xml" 
      title="MikeAmundsen and friends" 
      href="http://wego-wego.appspot.com/friendfeed/mamund/osd/" />
    <style type="text/css">
        h1,h2,h3,h4,h5,p,div,dl
        {
            margin:0 0 0 0;
            padding:0;
        }
        p.version,
        span.version
        {
            font-style:italic;
            font-size:small;
        }
        div#page-content
        {
            width:1100px;
            margin:auto;
        }
        div#details
        {
            margin:1em 0;
        }
        div.section p
        {
            margin:.5em 0;
        }
        dt
        {
            font-weight:bold;
        }
        dt span.date
        {
            font-weight:normal;
            font-style:italic;
            font-size:small;
        }
        dd
        {
            margin-bottom: .5em;
        }
        a.rfc,a.rfc:visited,a.rfc:link,a.rfc:hover
        {
            color:#900;
            font-weight:normal;
        }
        code
        {
            font-weight:bold;
        }
				pre.code
				{
						margin: 0 2em;
						background-color: #e5e5e5;
						border: 1px solid black;
						padding: .2em 1em;
				}
        .reduce-charges
        {
            color:green;
            font-style:italic;
        }
        a,a:visited,a:hover,a:link
        {
            color:blue;
        }
        .section p.first
        {
            margin-top:0;
        }
        p.note
        {
            font-style:italic;
        }
        a.indoc,a.indoc:hover,a.indoc:visited,a.indoc:link
        {
            color:#000;
        }
        .progress
        {
            color:#000;
            font-weight:normal;
            background-color:#ccc;
            border:1px solid black;
            padding:.3em;
        }
        span.headline
        {
        		display:block;
        		font-weight:bold;
        		margin:0;
        }
        .hidden
        {
            display:none;
        }
        .alert
        {
            border:1px solid red;
            padding: .2em;
            background-color:#ffc;
        }
        .alert h3,h4,p
        {
            margin:0;
        }
    </style>
</head>
<body>
    <div id="page-content">
      <div id="ads" style="text-align:center;">
        <script type="text/javascript">
            <!--
            google_ad_client = "pub-2944238157647009";
            google_ad_width = 728;
            google_ad_height = 90;
            google_ad_format = "728x90_as";
            google_ad_type = "text_image";
            //2007-08-10: hikeweb
            google_ad_channel = "4794860677";
            google_color_border = "000000";
            google_color_bg = "F0F0F0";
            google_color_link = "000000";
            google_color_text = "000000";
            google_color_url = "000000";
            //-->
        </script>
        <script type="text/javascript"
          src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
        </script>
      </div>
      <div id="details">
        <h1 id="home" title="Home">Azure Feature Wish List</h1>
				<h4>Exploring Windows Azure services.</h4>
        <p class="version">updated: 2009-02-25 (v1.2)</p>
		  </div>
      <div id="links">
      <ul>
        <li><a href="../index.html">Home</a></li>
        <li><a href="index.html">Azure Feature Wishlist</a></li>
        <li><a href="../feedback/index.html">Feedback</a></li>
        <li><a href="http://github.com/mamund/azure-examples/tree/master" title="azure-examples">github</a></li>
        <li><a href="http://code.google.com/p/azure-examples/" title="azure-examples">GoogleCode</a></li>
        <li><a href="http://social.msdn.microsoft.com/Forums/en-US/category/azure/" title="Azure @ MSDN Forums">MSDN Forums</a></li>

        <li><a href="http://code.google.com/p/azure-examples/downloads/list" title="Download the code">Download</a></li>
      </ul>
		</div>
		<div class="alert hidden">
		    <h4>NOTE</h4>
		    <p>
		    </p>
		</div>
        <div class="section">
            <p>
                This page contains features and other 'wish list' items I've collected while working with Microsoft's
                <a href="http://www.microsoft.com/azure/data.mspx" title="Azure Storage.">Azure Storage</a>. You might notice that most of the requests
                I list here relate to 'application protocol' level items - HTTP. That's because I am currently most
                interested in these issues and I have not found too many others covering the same space.
                I know there are lots of important database-related features that Azure Storage can include, too. I leave
                the work of documenting those feature requests to others.
            </p>
            <p>
                The Azure team maintains serveral <a href="http://social.msdn.microsoft.com/Forums/en-US/category/azure/" title="Azure Forums">
                active forums</a> for anyone who wishes to join. There is also an official <a href="http://blogs.msdn.com/windowsazure/" title="Windows Azure">
                blog</a>. You'll find lots of the items on this page covered in these other sources. However,
                I had a hard time keeping track of progress on several of these items. So I started this page to try to
                keep a easy-to-find linkable list of items related to Azure Storage.
            </p>
            <p>
                Of course, this list is in no way official or comprehensive. It's not meant to be a 'sink' for Azure Storage feature requests.
                If you like some of the stuff here - cool. If you think some of it is just lame, I accept that. If you think
                I've missed some important items, you're not be alone. I encourage you to publish your own feature lists for Azure Storage to consider.
                Feel free to post your comments on my
                <a href="../feedback/index.html" title="Feedback for Azure Examples">Azure Feedback</a> page.
            </p>
        </div>
        <div class="section">
            <h2>Wish List</h2>

            <dl>
								<dt><a name="normalize-request-signing" title="normalize-request-signing" class="indoc">Normalize Request Signing</a> <span class="date">2009-02-25</span></dt>
								<dd>
										<p class="first">
												Currently Azure Storage (Table, Blob, and Queue) uses a request-signing pattern. However, all collections do not share the
												same rules. The <a href="http://msdn.microsoft.com/en-us/library/dd179428.aspx" title="Authentication Schemes ">Azure Storage Services documentation</a>
												lists two rules for accessing storage:
										</p>
										<h4>Blob and Queue Storage (Shared Key Authentication)</h4>
										<pre class="code">
StringToSign = VERB + "\n" +
  Content-MD5 + "\n" +
  Content-Type + "\n" +
  Date + "\n" +
  CanonicalizedHeaders + 
  CanonicalizedResource;
										</pre>
										<h4>Table Storage (Shared Key Authentication)</h4>
										<pre class="code">
StringToSign = VERB + "\n" + 
  Content-MD5 + "\n" + 
  Content-Type + "\n" +
  Date + "\n" +
  CanonicalizedResource;
										</pre>
										<p class="note">There are also different rules on how to handle the <code>Date</code> portion of the request signature.</p>
								    <p>
												Request signatures for Blob, Table, and Queue collections should be the same. Preferably, Blob and Queue collections
												should adopt the (simpler) Table signature rules. 
										</p>
										<p>
												In addition, using request-signing slows processing on both the client and the server. It also reduces the usability of the service since
												standard HTTP clients (common browsers, cUrl, wGet, WFetch) cannot form valid requests. This means standard HTTP clients
												must use a proxy service (custom-coded middleware) to access even public content. It would be better if Azure storage
												employed known public authentication schemes (HTTP Basic, HTTP Digest, etc.) and a shared authorization scheme (see elsewhere in
												this document).
										</p>
								</dd>
                <dt><a name="uri-cruft" class="indoc">Improve Resource Addressing by Removing URI 'Cruft'</a> <span class="date">2009-01-13</span></dt>
                <dd>
                  <p class="first">
                    Currently, Azure Storage uses the following URI patterns to address resources:
                  </p>
                  <ol>
                    <li><code>/customers()</code></li>
                    <li><code>/customers()?$filter=(PartitionKe%20eq%20'preferred')</code></li>
                    <li><code>/customers(PartitionKey="preferred",RowKey="c1234")</code></li>
                  </ol>
                  <p>
                    The first example returns all the Entities in the <code>Customer</code> table. The second example returns all the Entities in the
                    <code>Customers</code> table assigned to the <b>preferred</b> partition. The last example returns a single Entity in the <code>Customers</code>
                    collection that matches both the PartitionKey and RowKey values. 
                  </p>
                  <p>This URI pattern has too much 'technology leaking' and is unecessarily 'crufty.' Instead, the following URI patterns are simpler, more intuitive and
                  more direct.
                  </p>
                  <ol>
                    <li><code>/customers/</code></li>
                    <li><code>/customers/preferred/</code></li>
                    <li><code>/customers/preferred/c1234</code></li>
                  </ol>
                  <p>
                    Making this change will improve the usability of Azure Storage and increase the likelihood of adoption from a wide range of User-Agents and platforms.
                    It will also hide the details of the underlying implementation and make it less brittle and less likely to 'break' as the underlying technology changes
                    over time. 
                  </p>
                  <p class="note">
            	  		<span class="headline">NOTE</span>It is also possible to create Entities that have no PartitionKey, but this is not advisable.
                  </p>
                </dd>
            	  <dt><a name="permission-access" class="indoc">Support Permission-style Access Security based on HTTP Method + URI</a> <span class="date">2009-01-07</a></dt>
            	  <dd>
            	  	<p class="first">
            	  		Currently Azure Storage a single user account that has full access to all operations (Create, Read, Update, Delete) for all Azure Storage objects
            	  		(Tables and Entities). Azure Storage should also provide support for multiple user accounts with
            	  		granular access to the same Azure Storage objects. In keeping with Azure Storage's support for REST-like interaction, it is proposed
            	  		that access security for Azure Storage be based on <em>permissions</em> (and not <em>roles</em>) and that the permissions
            	  		be mapped directly to HTTP methods: <code>POST</code>(<em>Create</em>), <code>GET</code>(<em>Read</em>),
            	  		<code>PUT</code>(<em>Update</em>), and <code>DELETE</code>(<em>Delete</em>).
            	  	</p>

            	  	<p>
            	  		Further, it is proposed that these permissions be applied directly to the URIs that are used to request
            	  		Azure Storage objects. For example <code>http://[account-name].table.core.windows.net</code> [<em>POST, GET</em>] is
            	  		a security rule that allows only Read and Create rights for, in this case Authorities. This pattern
            	  		can be expanded by using a templating notation (i.e. regular expressions). For example, the following
            	  		rule defines read-only access for the selected /table: 
            	  		<code>http://[account-name].table.core.windows.net/my-table/(.*) [<em>GET</em>]</code>.
            	  	</p>
            	  	<p>
            	  		Finally, these security access rules (<code>URI+HTTP-Method-list</code>) can be associated with one or
            	  		more user accounts to complete the access control features of Azure Storage. Also, it is possible to associate
            	  		one or more security access rules with a role|group and then associate one or more user accounts with
            	  		that group. In this way, Azure Storage can implement support for 'role-based' security.
            	  	</p>

            	  	<p class="note">
            	  		<span class="headline">NOTE:</span> It is not recommended that access security be based on values that do not appear in the URI (i.e. cookies, 
            	  		custom headers, etc.) since this can break intermediaries (caching, security proxies, etc.) and could 
            	  		result in the exact same URI returning different data to the user-agent based on the contents of these
            	  		'hidden' values. For the same reasons, it is not recommended that access security be based on the contents of
            	  		Entity objects (i.e. <em>Kind</em>) since this is data 'hidden' in the body of the response and not 
            	  		available via the URI itself.
                  </p>
            	  </dd>
                
            		<dt><a name="digest-auth" class="indoc">Provide Support for HTTP Basic and Digest Authentication</a> <span class="date">2009-01-07</span></dt>
            		<dd>
            			<p class="first">
            				Currently Azure Storage supports a custom request-signing authetication pattern. In addition, Azure Storage should offer user-agents the option
            				of using the Basic and/or Digest authentication in line with <a href="http://www.ietf.org/rfc/rfc2617.txt" class="rfc" title="rfc2617">HTTP Authentication</a>.
                    While the Digest authentication algorithm is more secure than the Basic algorithm, both forms are essential for supporting automated user-agent
                    interaction with the Azure Storage data servers. 
            			</p>
            		</dd>
                
                <dt><a name="paging-headers" class="indoc">Provide Support for Paging Indicators as Custom HTTP Headers</a> <span class="date">2009-01-07</span></dt>
                <dd>
                    <p class="first">
                    Currently Azure Storage implements "paging" using custom "continuation" HTTP headers to provide hints for additional Entities available on the server.
                    This offers a simple "forward-only" paging pattern, but falls short of full support for paging large amounts of data. Azure Storage needs a complete
                    paging solution.
                    </p>
                    <p>
                    A good example of a pattern already 'vetted' by the community is the
                    <a href="http://tools.ietf.org/rfc/rfc5005.txt"class="rfc" title="rfc5005">Feed Paging and Archiving</a> standard developed for the
                    <a href="http://www.rfc-editor.org/rfc/rfc4287.txt" class="rfc" title="rfc4287">Atom</a> MIME-type.
                    Since Azure Storage already supports Atom, using the above-mentioned RFC standard seems a good target.
                    </p>
                    <p>
                    For MIME-types other than Atom, it is suggested that a set of custom HTTP Headers be employed to cover the same values.
                    Suggested names are: <code>x-paging-first, x-paging-previous, x-paging-next, x-paging-last</code>. In line with
                    RFC5005 (see above), the values should be links, not scalar values. This allows the greatest flexibility for future changes to the
                    way paging is used and/or computed (i.e. <code>x-paging-next: http://example.com/table/entity-25</code>)
                    </p>
                    <p>
                    Another possible solution would be to consider the
                    <a href="http://www.mnot.net/drafts/draft-nottingham-http-link-header-00.txt" class="rfc" title="draft-nottingham-http-link-header-00">HTTP Header Linking</a>
                    draft from Mark Nottingham (i.e. <code>link:&lt;http://example.com/table/&gt;; rel="first")</code>.
                    While this draft is currently dormant, it has potential for wider acceptance over adopting custom HTTP headers.
                    </p>

                </dd>
                <dt><a name="cache-control" class="indoc">Support Cache-Control:no-cache and/or Pragma:no-cache HTTP Header</a> <span class="date">2009-01-07</span></dt>
                <dd>
                    Azure Storage should support the use of
                    <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9" class="rfc" title="rfc2616">Cache-Control:no-cache</a> (HTTP/1.1) and/or
                    <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.32" class="rfc" title="rfc2616">Pragma:no-cache</a> (HTTP/1.0).
                    This allows the user agent to indicate to the server that a fresh copy of the resource should be sent
                    regardless of the expiration or validation caching in force. Specifically, in cases where user agents send
                    Azure Storage the Cache-control:no-cache or Pragma:no-cache headers, any If-None-Match header should be ignored.
                    This allows user agents to explicitly request a fresh copy of the resource and update any intermediary caches
                    in the path between the user agent and the server.
                </dd>


                <dt><a name="last-modified" class="indoc">Support Last-Modified. If-Modified-Since, and If-Unmodified-Since Headers</a> <span class="date">2009-01-07</span></dt>
                <dd>
                    Currently, Azure Storage supports conditional GET and conditional PUT via the
                    <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.19" class="rfc" title="rfc2616">ETag</a>,
                    <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.26" class="rfc" title="rfc2616">If-None-Match</a> (for conditional GET), and
                    <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.24" class="rfc" title="rfc2616">If-Match</a> (for conditional PUT).
                    In addition to ETags, Azure Storage should also support
                    <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.29" class="rfc" title="rfc2616">Last-Modified</a>,
                    <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.25" class="rfc" title="rfc2616">If-Modified-Since</a> (for conditional GET), and
                    <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.28" class="rfc" title="rfc2616">If-Unmodified-Since</a> (for conditional PUT).
                    Adding support for these HTTP Headers will allow clients to use the *-Modified Headers instead of ETag headers.
                    <span class="reduce-charges">Supporting this feature can reduce charges to the Azure Storage account-holder.</span>

                </dd>
                <dt><a name="multiple-media-types" class="indoc">Support multiple media-types for the same Entity</a> <span class="date">2009-01-07</span></dt>
                <dd>
                    Currently, with the exception of BLOB support, Azure Table Storage only supports Atom and JSON Internet media types
                    when requesting Table and Entity objects. That means clients that wish to consume other
                    MIME-types (HTML, CSV, Plain Text, PDF, etc.) must rely on a 'transformation proxy' to convert the data
                    to the desired format. Azure Storage should support 
                    <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec12.html#sec12.1" class="rfc" title="rfc2616">server-driven content negotation</a>
                    using standard MIME-types via the
                    <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.1" class="rfc" title="rfc2616">Accept</a>

                    and <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.17" class="rfc" title="rfc2616">Content-Type</a>
                    HTTP headers. That means the URI for the resource (<code>/table/entity-id</code>) <em>should not</em>
                    change depending on the MIME-type (i.e. <code>/atom/table/entity-id</code> is not allowed). Text-based
                    media types that are desirable include
                    <a href="http://www.rfc-editor.org/rfc/rfc2854.txt" class="rfc" title="rfc2854">HTML</a>, and
                    <a href="http://www.rfc-editor.org/rfc/rfc4180.txt" class="rfc" title="rfc4180">CSV</a>.
                    Additional types that would improve the user-agent experience include
                    <a href="http://www.rfc-editor.org/rfc/rfc3778.txt" class="rfc" title="rfc3778">PDF</a> and
                    <a href="http://www.w3.org/TR/2005/WD-SVGMobile12-20050413/mimereg.html#mime-registration" class="rfc" title="WD-SVGMobile12-20050413">SVG</a>. 
                </dd>

                <dt><a name="content-md5" class="indoc">Support Content-MD5 Header</a> <span class="date">2009-01-07</span><dt>
                <dd>
            	  <p class="first progress">
										<span class="headline">2009-01-30</span>
										I confirmed that Azure table storing *does* support the <code>content-MD5</code> header.
										I missed this in my initial review of the feature set.
								</p>
										Supporting the <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.15" class="rfc" title="rfc2616">Content-MD5</a>
                    header allows the user-agent to send an <a href="http://www.ietf.org/rfc/rfc1321.txt" class="rfc" title="rfc1321">MD5</a> hash of
                    the entity body with the POST/PUT request. The server can then (optionally) perform an MD5 hash and compare the results with the
                    hash supplied by the user-agent. If they do not match, the server can reject the request and send an error response code. This is
                    especially helpful for large and/or binary entity bodies sent from user-agents.
                    <span class="reduce-charges">Supporting this feature can reduce charges to the Azure Storage account-holder.</span>

                </dd>

                <dt><a name="http-head" class="indoc">Support HTTP HEAD method</a> <span class="date">2009-01-07</span></dt>
                <dd>
                 	<p>	
                    Using the <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.4" class="rfc" title="rfc2616">HEAD</a>
                    method will allow user-agents to check for the existence of a resource (Entity) before making the actual request.
                    This call can also be used to cut down on traffic and bandwidth since making a HEAD call w/ the server-supplied
                    <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.19" class="rfc" title="rfc2616">ETag</a>
                    will allow the user-agent to determine if a new copy of the Entity exists on the server. This can improve scalability
                    and runtime performance.
                    <span class="reduce-charges">Supporting this feature can reduce charges to the Azure Storage account-holder.</span>
                  </p>
                </dd>

                <dt><a name="location-header" class="indoc">Return Location Header for POST, PUT, DELETE</a> <span class="date">(2008-11-25)</span></dt>
                <dd>
                    When doing as POST, PUT or DELETE return the
                    <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.30" class="rfc" title="rfc2616">Location</a>
                    HTTP Header that that points to the updated resource (for POST and PUT) or the resource list (for DELETE).
                    This value allows user-agents to perform a GET using the value in the Location header in order to be sure to get the most
                    recent version of the resource. This is especially important when returning HTTP Status Code
                    <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.2.2" class="rfc" title="rfc2616">201</a>
                    (for POST) or <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.2.5" class="rfc" title="rfc2616">204</a>

                    (for DELETE) [see below]. This can improve performance and scalability by lowering traffic between user-agent and server.
                    <span class="reduce-charges">Supporting this feature can reduce charges to the Azure Storage account-holder.</span>
    
                </dd>

                <dt><a name="no-body" class="indoc">Do not return a body on POST or PUT responses</a> <span class="date">2009-01-07</span></dt>
                <dd>
                	<p>	
                    Instead of returning the resulting Entity from a POST or PUT, return the appropriate HTTP Status Code
                    with a <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.30" class="rfc" title="rfc2616">Location</a>
                    HTTP Header that points to the resulting Entity. For POST, return
                    <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.2.2" class="rfc" title="rfc2616">201</a> (Created).
                    For PUT, return <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.2.5" class="rfc" title="rfc2616">204</a>
                    (No Content). This is especially helpful when handling large binary objects as it
                    cuts down on possibly needless traffic and bandwidth. 
                    <span class="reduce-charges">Supporting this feature can reduce charges to the Azure Storage account-holder.</span>

                  </p>
                </dd>
                <dt><a name="etag-for-lists" class="indoc">Return ETags and support HTTP Status code 304 for Entity Lists/Queries</a> <span class="date">2009-01-07</span></dt>
                <dd>
                    Currently Azure Storage returns an <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.19" class="rfc" title="rfc2616">ETag</a>
                    for GETs on a single Entity, but not on GETs that return more than oneEntity. This means that user-agents cannot easily
                    cache query results (or even simple, non-filtered lists). It also means that when a user-agent repeats the same GET
                    for a list, it has no ETag to return which means Azure Storage cannot return a
                    <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.5" class="rfc" title="rfc2616">304</a> (Not Modified).
                    This increases traffic and bandwidth to Azure Storage servers. 
                    <span class="reduce-charges">Supporting this feature can reduce charges to the Azure Storage account-holder.</span>

                </dd>
                <dt><a name="encoding" class="indoc">Support Accept-Encoding and Content-Encoding Headers</a> <span class="date">2009-01-07</span></dt>
                <dd>
                    Azure Storage should support <a href="http://www.ietf.org/rfc/rfc1952.txt" class="rfc" title="rfc1952">GZip</a> and
                    <a href="http://www.ietf.org/rfc/rfc1951.txt" class="rfc" title="rfc1951">Deflate</a> encoding when generating responses.
                    When user agents send the <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.3" class="rfc" title="rfc2616">Accept-Encoding</a>

                    HTTP header, Azure Storage servers should evaulate the header and, when appropriate, encode the results and return the
                    <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.11" class="rfc" title="rfc2616">Content-Encoding</a>
                    HTTP Header as part of the response. Encoding reduces bandwidth for both server and user-agent.
                    All major browsers and most HTTP libraries automatically support GZip and Deflate.
                    This can result in better response times from the server.
                    <span class="reduce-charges">Supporting this feature can reduce charges to the Azure Storage account-holder.</span>                
                </dd>
            </dl>
        </div>
    </div>
</body>
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript"></script> 

<script type="text/javascript"> 
		_uacct = "UA-2399548-1";
		urchinTracker();
</script> 
</html>
