<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Implementing a Simple Word Search Using Azure Table Storage</title><link rel="stylesheet" href="html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.74.0"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="article" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="d0e1"></a>Implementing a Simple Word Search Using Azure Table Storage</h2></div><div><h3 class="subtitle"><i>Exploring Schema-less Storage Patterns</i></h3></div><div><div class="author"><h3 class="author"><span class="firstname">Mike</span> <span class="surname">Amundsen</span></h3></div></div><div><p class="pubdate">2009-03-10</p></div></div><hr></div><div class="toc"><dl><dt><span class="section"><a href="index.html#d0e14">1. Introduction</a></span></dt><dt><span class="section"><a href="index.html#d0e38">2. A Different Storage Model</a></span></dt><dt><span class="section"><a href="index.html#d0e94">3. Seeing Data in a New Way</a></span></dt><dd><dl><dt><span class="section"><a href="index.html#d0e111">3.1. Typical RDBMS Solution</a></span></dt><dt><span class="section"><a href="index.html#d0e145">3.2. A Schema-less Alternative</a></span></dt><dd><dl><dt><span class="section"><a href="index.html#d0e162">3.2.1. The Messages Entity Collection</a></span></dt><dt><span class="section"><a href="index.html#d0e187">3.2.2. The Search Entity Collection</a></span></dt><dt><span class="section"><a href="index.html#d0e227">3.2.3. Search Results - And Some Tweaks</a></span></dt><dt><span class="section"><a href="index.html#d0e346">3.2.4. Some Caveats: Views, Sharding, and Updates</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="index.html#d0e378">4. Summary</a></span></dt></dl></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e14"></a>1.&nbsp;Introduction</h2></div></div></div><p>As 'schema-less' storage becomes more prevalent, the patterns and practices learned from relational data storage models may be inappropriate for familiar data-handling situations. One example is the task of implementing a simple word search pattern for a short message application (i.e. <a class="ulink" href="http://twitter.com" target="_top">Twitter</a>). With schema-less storage systems, using near-match keywords such as <code class="code">LIKE</code>, linking different table sets using <code class="code">JOIN</code>, and sorting the returned results via secondary indexes are often unavailable. Instead, new implementation strategies must be employed to get the same results.</p><p>This article will walk the reader through a simple scenario (implementing a word search against stored messages) and compare common relational data model practices to techniques that work for schema-less storage models. <a class="ulink" href="http://msdn.microsoft.com/en-us/library/dd179423.aspx" target="_top">Azure Table Storage</a> is used in this example, but the same approach will work for similar storage systems including Amazon's <a class="ulink" href="http://aws.amazon.com/simpledb/" target="_top">SimpleDB</a>.</p><p>In addition, this article outlines a some strategies that can be applied to a wide range schema-less storage solutions.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e38"></a>2.&nbsp;A Different Storage Model</h2></div></div></div><p>Azure Table Storage is organized as a variable set of properties tied to a few basic predefined keys. In Azure storage, those keys are the table name, the partition key, and the row key. This '<a class="ulink" href="http://en.wikipedia.org/wiki/Entity-Attribute-Value_model" target="_top">Entity-Attribute-Value</a>' (<acronym class="acronym">EAV</acronym>) data model supports search and key-based retrieval engines that return results very quickly even when the data is stored in more than one location. In fact, one of the great advantages of <acronym class="acronym">EAV</acronym>s is that they very effective on widely distributed, heterogeneous data collections.</p><p>There are some downsides to the <acronym class="acronym">EAV</acronym> model. Over the last forty years the '<a class="ulink" href="http://en.wikipedia.org/wiki/RDBMS" target="_top">Relational Database Management System</a>' (<acronym class="acronym">RDBMS</acronym>) approach has dominated computer data storage. Developers have grown comfortable with powerful features of relation data models including foreign-key validation, the ability to create custom indexes to support searching, and the ability to iterate over several tables in a single query to produce 'joined' result sets.</p><p><acronym class="acronym">EAV</acronym> models usually do not support relational concepts such as <code class="code">JOIN</code> or <code class="code">LIKE</code> in queries. Even when <acronym class="acronym">EAV</acronym>s support these features, the implementation can be less than complete and/or performance suffers. In fact, these types of 'relational idioms' are not appropriate when working with <acronym class="acronym">EAV</acronym> data stores. Creating successful <acronym class="acronym">EAV</acronym> queries means thinking about data storage in a different way. For example, in an <acronym class="acronym">EAV</acronym> model, <a class="ulink" href="http://en.wikipedia.org/wiki/Database_normalization" target="_top">database normalization rules</a> can be a hindrance to performance. With <acronym class="acronym">EAV</acronym>s, we may need to consider changing where and in what form we store our data. We may need to use compiled code or scripts to produce the desired output. That includes the possibility of employing asynchronous and/or parallel coding to speed execution against one or more physical data stores at various locations on the Internet. In other words, we need to adopt different idioms when working with <acronym class="acronym">EAV</acronym>s.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e94"></a>3.&nbsp;Seeing Data in a New Way</h2></div></div></div><p>Implementing a word search is an example of the challenges <acronym class="acronym">EAV</acronym>s can pose to those not familiar with this different data model. Using standard <acronym class="acronym">T-SQL</acronym>, supporting word searches against a table field is relatively trivial. However, with <acronym class="acronym">EAV</acronym> models the lack of table-scanning query features such as the <code class="code">LIKE</code> keyword and the (sometimes) lack of secondary index support mean familiar tactics may not apply.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e111"></a>3.1.&nbsp;Typical RDBMS Solution</h3></div></div></div><p>As a start, let's review the details of implementing a simple word search on a single field (<code class="code">MessageText</code>) in a single table (<code class="code">Messages</code>) using common <acronym class="acronym">T-SQL</acronym>. Fist, we need to define our <code class="code">Message</code> table.</p><pre class="programlisting">CREATE TABLE Messages
  (Id integer PRIMARY KEY,
   MessageText varchar(140),
   Author varchar(50),
   DateCreated date);
</pre><p>The easiest way to implement the word search against this table is to use the <code class="code">LIKE</code> keyword in a <code class="code">SELECT</code> query:</p><pre class="programlisting">CREATE PROCEDURE wordSearch
  @word varchar(50)
  SELECT Id, MessageText, Author, DateCreated FROM Messages
  WHERE MessageText LIKE '%'+@word+'%'</pre><p>There are some details, such as adding an index on the <code class="code">MessageText</code> field to speed things along, but the essentials are all here. This solution will run into problems as the data table grows, but for many cases, this is the common approach to the problem.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e145"></a>3.2.&nbsp;A Schema-less Alternative</h3></div></div></div><p>Implementing a word search in Azure Table Storage is not quite as easy. First we don't have an equivalent to the <code class="code">LIKE</code> keyword at our disposal. Second, we don't have the ability to create secondary indexes on a table (or Entity collection in <acronym class="acronym">EAV</acronym>-speak). That means we need to do the work ourselves. Essentially, we need to build a table to hold the links between search words and the actual <code class="code">Message</code> records. Doing this will allow us to mimic the <code class="code">LIKE</code> keyword from relation query languages.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e162"></a>3.2.1.&nbsp;The <code class="code">Messages</code> Entity Collection</h4></div></div></div><p>To begin, we need to define the <code class="code"><code class="code">Messages</code></code> entity collection, This will hold the same data as the <acronym class="acronym">T-SQL</acronym> <code class="code">Messages</code> table we defined earlier:</p><pre class="programlisting">&lt;content type="application/xml" 
  xmlns:d="http://schemas.microsoft.com/ado/2007/08/dataservices" 
  xmlns:m="http://schemas.microsoft.com/ado/2007/08/dataservices/metadata"&gt;
  &lt;m:properties&gt;
    &lt;d:PartitionKey&gt;Messages&lt;/d:PartitionKey&gt;
    &lt;d:RowKey&gt;1000&lt;/d:RowKey&gt;
    &lt;d:MessageText&gt;The first message&lt;/d:MessageText&gt;
    &lt;d:DateCreated m:type="Edm.DateTime"&gt;2009-03-01T12:00:00.000Z&lt;/d:DateCreated&gt;
  &lt;/m:properties&gt;
&lt;/content&gt;
</pre><p>Note that we do not define a schema for the <code class="code">Message</code> collection. Instead we simply build a record and write it to the data store. This is the essence of working with schema-less storage.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e187"></a>3.2.2.&nbsp;The <code class="code"><code class="code">Search</code></code> Entity Collection</h4></div></div></div><p>Next we need to build a collection that will allow us to return all the <code class="code">Message</code> entities that contain the word in our search criteria. As shown in the previous example, we only need to write the entities directly to the data store; no schema definition is needed. Below is a set of <code class="code">Search</code> entities for the <code class="code">MessageText</code> from the previous example.</p><pre class="programlisting">&lt;content type="application/xml" 
  xmlns:d="http://schemas.microsoft.com/ado/2007/08/dataservices" 
  xmlns:m="http://schemas.microsoft.com/ado/2007/08/dataservices/metadata"&gt;
  &lt;m:properties&gt;
    &lt;d:PartitionKey&gt;Search&lt;/d:PartitionKey&gt;
    &lt;d:RowKey&gt;1001&lt;/d:RowKey&gt;
    &lt;d:Word&gt;the&lt;/d:MessageText&gt;
    &lt;d:MessageId&gt;1000&lt;/d:MessageText&gt;
    &lt;d:DateCreated m:type="Edm.DateTime"&gt;2009-03-01T12:00:00.000Z&lt;/d:DateCreated&gt;
  &lt;/m:properties&gt;
&lt;/content&gt;

&lt;content type="application/xml" 
  xmlns:d="http://schemas.microsoft.com/ado/2007/08/dataservices" 
  xmlns:m="http://schemas.microsoft.com/ado/2007/08/dataservices/metadata"&gt;
  &lt;m:properties&gt;
    &lt;d:PartitionKey&gt;Search&lt;/d:PartitionKey&gt;
    &lt;d:RowKey&gt;1002&lt;/d:RowKey&gt;
    &lt;d:Word&gt;first&lt;/d:MessageText&gt;
    &lt;d:MessageId&gt;1000&lt;/d:MessageText&gt;
    &lt;d:DateCreated m:type="Edm.DateTime"&gt;2009-03-01T12:00:00.000Z&lt;/d:DateCreated&gt;
  &lt;/m:properties&gt;
&lt;/content&gt;

&lt;content type="application/xml" 
  xmlns:d="http://schemas.microsoft.com/ado/2007/08/dataservices" 
  xmlns:m="http://schemas.microsoft.com/ado/2007/08/dataservices/metadata"&gt;
  &lt;m:properties&gt;
    &lt;d:PartitionKey&gt;Search&lt;/d:PartitionKey&gt;
    &lt;d:RowKey&gt;1003&lt;/d:RowKey&gt;
    &lt;d:Word&gt;message&lt;/d:MessageText&gt;
    &lt;d:MessageId&gt;1000&lt;/d:MessageText&gt;
    &lt;d:DateCreated m:type="Edm.DateTime"&gt;2009-03-01T12:00:00.000Z&lt;/d:DateCreated&gt;
  &lt;/m:properties&gt;
&lt;/content&gt;
</pre><p>In the above example, a <code class="code">Search</code> entity is created for each unique word in the <code class="code">Message</code> entity. Each <code class="code">Search</code> entity contains the word itself along with a pointer to the <code class="code">Message</code> entity that contains that word. Note that the <code class="code">&lt;d:Word /&gt;</code> element in the entity holds a lowercase version of the one in the original <code class="code">Message</code> entity. This is a way of 'normalizing' the search-able data. Along with making the search words lowercase, it may be appropriate removing punctuation, extra spaces, etc.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e227"></a>3.2.3.&nbsp;Search Results - And Some Tweaks</h4></div></div></div><p>Once the <code class="code">Search</code> entities are created, executing a query to find all the <code class="code">Message</code> records that use a specific word is straight-forward. Here's a sample query that is valid for Azure Table Storage:</p><pre class="programlisting">/Search$filter=(Word eq 'first')</pre><p>The above query will return a list of <code class="code">Search</code> entities that point to all the <code class="code">Message</code> entities containing the search word. Depending on what is needed, the result document can contain a simple count of the found entities or the query results can be presented as a set of links:</p><pre class="programlisting">&lt;results xml:base="http://example.org/"&gt;
  &lt;link href="1000" title="Message 1000" /&gt;
  &lt;link href="1100" title="Message 1100" /&gt;
  &lt;link href="2000" title="Message 2000" /&gt;
  &lt;link href="2009" title="Message 2009" /&gt;
&lt;/results&gt;</pre><p>Most user would expect more than Id numbers as a response to their search. If we had access to the <code class="code">JOIN</code> feature of <acronym class="acronym">T-SQL</acronym>, the solution would be easy. For example, we could <code class="code">JOIN</code> the <code class="code">Search</code> entities to the <code class="code">Message</code> entities and return the linked <code class="code">Message</code> entities themselves:</p><pre class="programlisting">CREATE PROCEDURE wordSearch2
  @search nvarchar(50)
  SELECT m.Id, m.MessageText 
  FROM Messages m 
  JOIN Search s on s.MessageId=m.MessageId 
  WHERE s.Word=@search</pre><p>However, <code class="code">JOIN</code> is not supported Azure Table Storage (or most <acronym class="acronym">EAV</acronym>s). So, we have at least two other options:</p><div class="itemizedlist"><ul type="disc"><li><p>Mimic the JOIN through compiled code</p></li><li><p>Alter the data model/storage pattern</p></li></ul></div><p>In the first option, we could query for the <code class="code">Search</code> entities and, using compiled code, iterate through the resulting collection to fetch each the related <code class="code">Message</code> entities. Once that is done we could build the results document. This option works for small collections, but as the number of entities grows, it turns out to be a sub-optimal solution.</p><p>The better option is the second one; modify the data stored in the <code class="code">Search</code> entity. In this case, adding one more elements to the Search entity (<code class="code">MessageText</code>), provides all the information needed to render the results in a way that most users would expect:</p><pre class="programlisting">&lt;content type="application/xml" 
  xmlns:d="http://schemas.microsoft.com/ado/2007/08/dataservices" 
  xmlns:m="http://schemas.microsoft.com/ado/2007/08/dataservices/metadata"&gt;
  &lt;m:properties&gt;
    &lt;d:PartitionKey&gt;Search&lt;/d:PartitionKey&gt;
    &lt;d:RowKey&gt;1003&lt;/d:RowKey&gt;
    &lt;d:Word&gt;message&lt;/d:MessageText&gt;
    &lt;d:MessageId&gt;1000&lt;/d:MessageText&gt;
    &lt;d:MessageText&gt;The first message&lt;/d:MessageText&gt;
    &lt;d:DateCreated m:type="Edm.DateTime"&gt;2009-03-01T12:00:00.000Z&lt;/d:DateCreated&gt;
  &lt;/m:properties&gt;
&lt;/content&gt;
</pre><p>Now rendering the results is straightforward:</p><pre class="programlisting">&lt;results xml:base="http://example.org/"&gt;
  &lt;link href="1000" title="The first message." /&gt;
  &lt;link href="1100" title="I'm first in line for the movie!" /&gt;
  &lt;link href="2000" title="First things first." /&gt;
  &lt;link href="2009" title="I hate sitting in the first row." /&gt;
&lt;/results&gt;</pre><p>This last step is, in effect, a form of query optimization. In relational models, query optimization usually involves creating secondary indexes and/or modifying the <code class="code">SELECT</code> statement. In the <acronym class="acronym">EAV</acronym> model, optimization often means creating and/or modifying a custom entity collection. In this example, modifying the <code class="code">Search</code> entity in an <acronym class="acronym">EAV</acronym> model is similar to creating a <a class="ulink" href="http://en.wikipedia.org/wiki/Materialized_view" target="_top">materialized view</a> in a relational model.</p><p>It should also be noted that many <acronym class="acronym">EAV</acronym>s (Azure Table Storage among them) do not support creating secondary indexes in order to control the sort order of the query results. In that case, it is up to the designer of the 'view set' to set a primary key that returns the collection in the desired order. For example, Azure Table Storage uses a combination of the <code class="code">PartitionKey</code> and <code class="code">RowKey</code> to control the order of the result set. Thus, to return the search results in the reverse order in which they were created, we could modify the <code class="code">RowKey</code> to hold the proper value. In this case, subtracting the date/time the <code class="code">Message</code> entity was created from some far future date (<code class="code">futureDateTime.ticks - currentDateTime.ticks</code>) returns a value that automatically sorts as expected.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e346"></a>3.2.4.&nbsp;Some Caveats: Views, Sharding, and Updates</h4></div></div></div><p>In this simple example, some additional considerations remain unresolved. For example, if the implementation requires other common search collections (users who posted in the last ten days sorted by author, all messages added to the system in the last month sorted by date created, etc.) we would need to implement additional 'view collections' to meet those needs. This is similar to using the <code class="code">VIEW</code> and <code class="code">INDEX</code> features of modern relational data systems - except that <acronym class="acronym">RDBMS</acronym>' usually handle the details of maintaining the extra indexes and view sets. In <acronym class="acronym">EAV</acronym> models, it's up to the implementer to properly update the contents of the additional collections.</p><p>Also, most <acronym class="acronym">EAV</acronym> data stores have limits on the size of a single entity and of an entity container. That means, at some point, we need to consider organizing your data storage in to separate containers or <a class="ulink" href="http://en.wikipedia.org/wiki/Shard_(database_architecture)" target="_top">shards</a>. Sharding complicates queries since a complete query might need to cross more than one container; possibly all of them. A common solution is to launch parallel requests into each container and collect the results before formatting a response.</p><p>Finally, copying portions of source entities into query entities can adversely affect update semantics. Updating an existing record may require additional updates to one or more query entities. In order to prevent long wait times upon submitting updates, a common solution is to execute the query updates asynchronously. Depending the size of the data store, this can result in search results that are out of sync with the underlying source entities and might require additional error-handling when attempting to resolve search requests.</p><p>These caveats are all part of the cost of moving from a relational model to an <acronym class="acronym">EAV</acronym> model. The good news is that the solutions suggested here work whether the data stores are on your own server or out on the Internet; in a single location or spread over multiple servers. Also, depending on the data source, the same patterns can work across data stored in disparate formats.</p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e378"></a>4.&nbsp;Summary</h2></div></div></div><p>This article identified some key differences between relational and schema-less data models. Primarily the <acronym class="acronym">EAV</acronym> model's lack of support for <code class="code">LIKE</code>, <code class="code">JOIN</code>, and secondary indexing patterns normally found in relational data storage systems. The strategy of creating additional entity collections that mimic <acronym class="acronym">RDBMS</acronym> materialized views was given as one way to build applications that return the same results expected from relational systems. Also, the new challenges of maintaining custom views, handling data sharding, and keeping track of data changes were also identified. For example implementing parallel queries and asynchronous updates helps reduce wait times in <acronym class="acronym">EAV</acronym> data stores.</p><p>While it is true that <acronym class="acronym">EAV</acronym> data models currently require additional implementation effort, it is likely that, as the use of <acronym class="acronym">EAV</acronym>s increases, these additional patterns and practices will be 'baked' into code libraries or in some other way hidden from average data-handling chores. It is reasonable to expect that by the time <acronym class="acronym">EAV</acronym> storage reaches the same level of maturity as <acronym class="acronym">RDBMS</acronym> models (40 years and counting) implementation details will be no more demanding than, and just as reliable as, those experienced when implementing solutions on relational storage systems today.</p></div></div></body></html>